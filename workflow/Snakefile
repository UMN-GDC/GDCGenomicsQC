import os 


report: "../report/stylesheet.css"
configfile: "../config/config.yaml"
#validate(config, schema="../config/config.schema.yaml")

# Paths in include and configfile are relative to the Snakefile
# paths inside the rules are relative to where you run the command.

# CHROMOSOMES = range(1, 22)
CHROMOSOMES = range(20, 22)


# workflow.report_metadata.category_descriptions= {
#         "Initial QC": "../report/qc_intro.rst",
#         "Dimension reduction": "../report/dimensionReduction.rst",
#         "Ancestry Analysis": "../report/ancestry_intro.rst",
#         "Ancestry Specific QC": "../report/ancestrySpecificqc_intro.rst",
#     }

PREVIOUS_STEP = {
    "01-Initialfilter": "00-raw",
    "02-relatedness": "01-Initialfilter",
}

def get_input_by_stage(wildcards):
    # Fix the typo 'wilcards' -> 'wildcards'
    if wildcards.stage == "01-Initialfilter":
        input_prefix = "data"
    else:
        input_prefix = "initialFilter"

    # Ensure the stage exists in the map to avoid KeyErrors
    if wildcards.stage not in PREVIOUS_STEP:
        raise ValueError(f"Stage {wildcards.stage} not defined in PREVIOUS_STEP map.")

    prev = PREVIOUS_STEP[wildcards.stage]
    
    # Use os.path.abspath to make it bulletproof for SLURM
    path = os.path.join(config["OUT_DIR"], prev, input_prefix)
    return os.path.abspath(path)

# -------------------------------------------------------------------------
# AUTO-MOUNT LOGIC: Automatically bind directories found in config.yaml
# -------------------------------------------------------------------------

def get_hpc_mounts(config_data):
    """
    Recursively finds all absolute paths in the config and returns 
    a set of top-level mount points (e.g., /scratch.global, /panfs).
    """
    mounts = set()
    
    # 1. Always bind the current working directory and temp spaces
    defaults = [os.getcwd(), "/tmp", "/var/tmp"]
    for d in defaults:
        if os.path.exists(d):
            mounts.add(d)

    def scan_value(val):
        # If it's a dict or list, recurse
        if isinstance(val, dict):
            for v in val.values(): scan_value(v)
        elif isinstance(val, list):
            for v in val: scan_value(v)
        # If it's a string starting with '/', treat as path
        elif isinstance(val, str) and val.startswith("/"):
            # Split path to get the root mount (e.g., /scratch.global/user -> /scratch.global)
            parts = val.split(os.sep)
            if len(parts) > 1:
                root_mount = f"/{parts[1]}"
                # Only add if it actually exists on this machine
                if os.path.exists(root_mount):
                    mounts.add(root_mount)

    # 2. Scan the user's config
    scan_value(config_data)
    
    return ",".join(mounts)

# Check if we are using Singularity/Apptainer
use_singularity = config.get("use-singularity", False) or \
                  "--use-singularity" in sys.argv or \
                  "singularity" in str(getattr(workflow, "deployment_settings", ""))

if use_singularity:
    bind_paths = get_hpc_mounts(config)
    
    # Export to BOTH variables to cover Apptainer (new) and Singularity (old)
    os.environ["APPTAINER_BIND"] = bind_paths
    os.environ["SINGULARITY_BIND"] = bind_paths
    
    # Ensure writable tmpfs is on (fixes many 'read-only' errors)
    os.environ["APPTAINER_WRITABLE_TMPFS"] = "1"
    os.environ["SINGULARITY_WRITABLE_TMPFS"] = "1"

    # Print for debugging (so you can see what got mounted)
    print(f"\n[Auto-Mount] Detected and bound paths: {bind_paths}\n")

# -------------------------------------------------------------------------
# END AUTO-MOUNT LOGIC
# -------------------------------------------------------------------------


include: "rules/LinkData.smk"
include: "rules/Initial_QC.smk"
include: "rules/Relatedness.smk"
include: "rules/Standard_QC.smk"
include: "rules/phase.smk"
# include: "rules/RFMIX.smk"
include: "rules/trainGnomix.smk"
include: "rules/PCA.smk"
include: "rules/umap.smk"
include: "rules/estimateAncestry.smk"
include: "rules/plotInitial_QC.smk"


rule all:
    threads: 1
    resources:
        nodes = 1,
        mem_mb = 4000,
        runtime = 420 # 1 week
    input:
        # Requesting this file triggers Initial_QC for the first stage
        # os.path.join(config['OUT_DIR'], "00-raw/data.bed")
        #os.path.join(config['OUT_DIR'], "01-Initialfilter/initialFilter.bed")
        #os.path.join(config['OUT_DIR'], "02-relatedness/unrelated.bed"),
        #os.path.join(config['OUT_DIR'], "02-relatedness/initialFilter.bed")
        #os.path.join(config['OUT_DIR'], "02-relatedness/standardFiltered.bed")
        os.path.join(config['OUT_DIR'], "04-globalAncestry/merged_dataset_pca.eigenvec"),
        #expand(f"{config['OUT_DIR']}/03-localAncestry/chr{{CHR}}.phased.vcf.gz", CHR=CHROMOSOMES),
        os.path.join(config['OUT_DIR'], "figures/imiss.png"),
        os.path.join(config['OUT_DIR'], "figures/lmiss.png"),
        os.path.join(config['OUT_DIR'], "04-globalAncestry/latentDistantRelatedness.png"),
        os.path.join(config['OUT_DIR'], "04-globalAncestry/latentDistantRelatedness.csv"),

rule run_pca:
    threads: 1
    resources:
        nodes = 1,
        mem_mb = 4000,
        runtime = 420 # 1 week
    input:
        os.path.join(config['OUT_DIR'], "04-globalAncestry/merged_dataset_pca.eigenvec")

rule run_umap:
    threads: 1
    resources:
        nodes = 1,
        mem_mb = 4000,
        runtime = 420 # 1 week
    input:
        os.path.join(config['OUT_DIR'], "04-globalAncestry/umap.csv")

rule run_train_gnomix:
    threads: 1
    resources:
        nodes = 1,
        mem_mb = 4000,
        runtime = 420 # 1 week
    input:
        expand(f"{config['OUT_DIR']}/03-localAncestry/chr{{CHR}}_ancestry_gnomix", CHR=CHROMOSOMES),


  # rule run_rfmix:
  #     threads: 1
  #     resources:
  #         nodes = 1,
  #         mem_mb = 4000,
  #         runtime = 420 # 1 week
  #     input:
  #         expand(f"{config['OUT_DIR']}/03-localAncestry/chr{{CHR}}_lai.vcf.gz", CHR=CHROMOSOMES),


rule run_phase:
    threads: 1
    resources:
        nodes = 1,
        mem_mb = 4000,
        runtime = 420 # 1 week
    input:
        expand(f"{config['OUT_DIR']}/03-localAncestry/chr{{CHR}}.phased.vcf.gz", CHR=CHROMOSOMES),

rule run_estimateAncestry:
    threads: 1
    resources:
        nodes = 1,
        mem_mb = 4000,
        runtime = 420 # 1 week
    input:
        os.path.join(config['OUT_DIR'], "04-globalAncestry/latentDistantRelatedness.png"),
        os.path.join(config['OUT_DIR'], "04-globalAncestry/latentDistantRelatedness.csv"),

